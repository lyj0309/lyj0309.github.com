<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>webApi fetch使用 - FAKEV</title><meta name="Description" content="a IT blog"><meta property="og:title" content="webApi fetch使用" />
<meta property="og:description" content="fetch()的功能与 XMLHttpRequest 基本相同，但有三个主要的差异。 （1）fetch()使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fakev.cn/post/fetch/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-10-21T18:52:55+08:00" />
<meta property="article:modified_time" content="2021-10-21T18:52:55+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="webApi fetch使用"/>
<meta name="twitter:description" content="fetch()的功能与 XMLHttpRequest 基本相同，但有三个主要的差异。 （1）fetch()使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简"/>
<meta name="application-name" content="FAKEV">
<meta name="apple-mobile-web-app-title" content="FAKEV"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://fakev.cn/post/fetch/" /><link rel="prev" href="https://fakev.cn/post/wireguard/" /><link rel="next" href="https://fakev.cn/post/elastic/metricbeat/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "webApi fetch使用",
        "inLanguage": "zh-cn",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/fakev.cn\/post\/fetch\/"
        },"genre": "post","keywords": "前端","wordcount":  4179 ,
        "url": "https:\/\/fakev.cn\/post\/fetch\/","datePublished": "2021-10-21T18:52:55+08:00","dateModified": "2021-10-21T18:52:55+08:00","publisher": {
            "@type": "Organization",
            "name": "lyj"},"author": {
                "@type": "Person",
                "name": "lyj"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="FAKEV">FAKEV</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/"> 主页 </a><a class="menu-item" href="/post/"> 历史 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="FAKEV">FAKEV</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/" title="">主页</a><a class="menu-item" href="/post/" title="">历史</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="page single special"><h1 class="single-title animated pulse faster">webApi fetch使用</h1><div class="content" id="content"><p>fetch()的功能与 XMLHttpRequest 基本相同，但有三个主要的差异。
（1）fetch()使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。
（2）fetch()采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。
（3）fetch()通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来。
在用法上，fetch()接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象。它的基本用法如下。</p>
<p>fetch(url)
.then(&hellip;)
.catch(&hellip;)</p>
<p>下面是一个例子，从服务器获取 JSON 数据。</p>
<p>fetch(&lsquo;<a href="https://api.github.com/users/ruanyf%27" target="_blank" rel="noopener noreffer">https://api.github.com/users/ruanyf'</a>)
.then(response =&gt; response.json())
.then(json =&gt; console.log(json))
.catch(err =&gt; console.log(&lsquo;Request Failed&rsquo;, err));</p>
<p>上面示例中，fetch()接收到的response是一个 Stream 对象，response.json()是一个异步操作，取出所有内容，并将其转为 JSON 对象。
Promise 可以使用 await 语法改写，使得语义更清晰。</p>
<p>async function getJSON() {
let url = &lsquo;<a href="https://api.github.com/users/ruanyf%27;" target="_blank" rel="noopener noreffer">https://api.github.com/users/ruanyf';</a>
try {
let response = await fetch(url);
return await response.json();
} catch (error) {
console.log(&lsquo;Request Failed&rsquo;, error);
}
}</p>
<p>上面示例中，await语句必须放在try&hellip;catch里面，这样才能捕捉异步操作中可能发生的错误。
后文都采用await的写法，不使用.then()的写法。
二、Response 对象：处理 HTTP 回应
2.1 Response 对象的同步属性
fetch()请求成功以后，得到的是一个 Response 对象。它对应服务器的 HTTP 回应。</p>
<p>const response = await fetch(url);</p>
<p>前面说过，Response 包含的数据通过 Stream 接口异步读取，但是它还包含一些同步属性，对应 HTTP 回应的标头信息（Headers），可以立即读取。</p>
<p>async function fetchText() {
let response = await fetch('/readme.txt&rsquo;);
console.log(response.status); 
console.log(response.statusText);
}</p>
<p>上面示例中，response.status和response.statusText就是 Response 的同步属性，可以立即读取。
标头信息属性有下面这些。
Response.ok
Response.ok属性返回一个布尔值，表示请求是否成功，true对应 HTTP 请求的状态码 200 到 299，false对应其他的状态码。
Response.status
Response.status属性返回一个数字，表示 HTTP 回应的状态码（例如200，表示成功请求）。
Response.statusText
Response.statusText属性返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回&quot;OK&quot;）。
Response.url
Response.url属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。
Response.type
Response.type属性返回请求的类型。可能的值如下：
basic：普通请求，即同源请求。cors：跨域请求。error：网络错误，主要用于 Service Worker。opaque：如果fetch()请求的type属性设为no-cors，就会返回这个值，详见请求部分。表示发出的是简单的跨域请求，类似<form>表单的那种跨域请求。opaqueredirect：如果fetch()请求的redirect属性设为manual，就会返回这个值，详见请求部分。
Response.redirected
Response.redirected属性返回一个布尔值，表示请求是否发生过跳转。
2.2 判断请求是否成功
fetch()发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，fetch()才会报错，其他情况都不会报错，而是认为请求成功。
这就是说，即使服务器返回的状态码是 4xx 或 5xx，fetch()也不会报错（即 Promise 不会变为 rejected状态）。
只有通过Response.status属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功。请看下面的例子。</p>
<p>async function fetchText() {
let response = await fetch('/readme.txt&rsquo;);
if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) {
return await response.text();
} else {
throw new Error(response.statusText);
}
}</p>
<p>上面示例中，response.status属性只有等于 2xx （200~299），才能认定请求成功。这里不用考虑网址跳转（状态码为 3xx），因为fetch()会将跳转的状态码自动转为 200。
另一种方法是判断response.ok是否为true。</p>
<p>if (response.ok) {
// 请求成功
} else {
// 请求失败
}</p>
<p>2.3 Response.headers 属性
Response 对象还有一个Response.headers属性，指向一个 Headers 对象，对应 HTTP 回应的所有标头。
Headers 对象可以使用for&hellip;of循环进行遍历。</p>
<p>const response = await fetch(url);</p>
<p>for (let [key, value] of response.headers) { 
console.log(<code>${key} : ${value}</code>);<br>
}</p>
<p>// 或者
for (let [key, value] of response.headers.entries()) { 
console.log(<code>${key} : ${value}</code>);<br>
}</p>
<p>Headers 对象提供了以下方法，用来操作标头。
Headers.get()：根据指定的键名，返回键值。Headers.has()： 返回一个布尔值，表示是否包含某个标头。Headers.set()：将指定的键名设置为新的键值，如果该键名不存在则会添加。Headers.append()：添加标头。Headers.delete()：删除标头。Headers.keys()：返回一个遍历器，可以依次遍历所有键名。Headers.values()：返回一个遍历器，可以依次遍历所有键值。Headers.entries()：返回一个遍历器，可以依次遍历所有键值对（[key, value]）。Headers.forEach()：依次遍历标头，每个标头都会执行一次参数函数。
上面的有些方法可以修改标头，那是因为继承自 Headers 接口。对于 HTTP 回应来说，修改标头意义不大，况且很多标头是只读的，浏览器不允许修改。
这些方法中，最常用的是response.headers.get()，用于读取某个标头的值。</p>
<p>let response =  await  fetch(url);<br>
response.headers.get(&lsquo;Content-Type&rsquo;)
// application/json; charset=utf-8</p>
<p>Headers.keys()和Headers.values()方法用来分别遍历标头的键名和键值。</p>
<p>// 键名
for(let key of myHeaders.keys()) {
console.log(key);
}</p>
<p>// 键值
for(let value of myHeaders.values()) {
console.log(value);
}</p>
<p>Headers.forEach()方法也可以遍历所有的键值和键名。</p>
<p>let response = await fetch(url);
response.headers.forEach(
(value, key) =&gt; console.log(key, &lsquo;:&rsquo;, value)
);</p>
<p>2.4 读取内容的方法
Response对象根据服务器返回的不同类型的数据，提供了不同的读取方法。
response.text()：得到文本字符串。response.json()：得到 JSON 对象。response.blob()：得到二进制 Blob 对象。response.formData()：得到 FormData 表单对象。response.arrayBuffer()：得到二进制 ArrayBuffer 对象。
上面5个读取方法都是异步的，返回的都是 Promise 对象。必须等到异步操作结束，才能得到服务器返回的完整数据。
response.text()
response.text()可以用于获取文本数据，比如 HTML 文件。</p>
<p>const response = await fetch('/users.html');
const body = await response.text();
document.body.innerHTML = body</p>
<p>response.json()
response.json()主要用于获取服务器返回的 JSON 数据，前面已经举过例子了。
response.formData()
response.formData()主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。
response.blob()
response.blob()用于获取二进制文件。</p>
<p>const response = await fetch(&lsquo;flower.jpg&rsquo;);
const myBlob = await response.blob();
const objectURL = URL.createObjectURL(myBlob);</p>
<p>const myImage = document.querySelector(&lsquo;img&rsquo;);
myImage.src = objectURL;</p>
<p>上面示例读取图片文件flower.jpg，显示在网页上。
response.arrayBuffer()
response.arrayBuffer()主要用于获取流媒体文件。</p>
<p>const audioCtx = new window.AudioContext();
const source = audioCtx.createBufferSource();</p>
<p>const response = await fetch(&lsquo;song.ogg&rsquo;);
const buffer = await response.arrayBuffer();</p>
<p>const decodeData = await audioCtx.decodeAudioData(buffer);
source.buffer = buffer;
source.connect(audioCtx.destination);
source.loop = true;</p>
<p>上面示例是response.arrayBuffer()获取音频文件song.ogg，然后在线播放的例子。
2.5 Response.clone()
Stream 对象只能读取一次，读取完就没了。这意味着，前一节的五个读取方法，只能使用一个，否则会报错。</p>
<p>let text =  await response.text();
let json =  await response.json();  // 报错</p>
<p>上面示例先使用了response.text()，就把 Stream 读完了。后面再调用response.json()，就没有内容可读了，所以报错。
Response 对象提供Response.clone()方法，创建Response对象的副本，实现多次读取。</p>
<p>const response1 = await fetch(&lsquo;flowers.jpg&rsquo;);
const response2 = response1.clone();</p>
<p>const myBlob1 = await response1.blob();
const myBlob2 = await response2.blob();</p>
<p>image1.src = URL.createObjectURL(myBlob1);
image2.src = URL.createObjectURL(myBlob2);</p>
<p>上面示例中，response.clone()复制了一份 Response 对象，然后将同一张图片读取了两次。
Response 对象还有一个Response.redirect()方法，用于将 Response 结果重定向到指定的 URL。该方法一般只用在 Service Worker 里面，这里就不介绍了。
2.6 Response.body 属性
Response.body属性是 Response 对象暴露出的底层接口，返回一个 ReadableStream 对象，供用户操作。
它可以用来分块读取内容，应用之一就是显示下载的进度。</p>
<p>const response = await fetch(&lsquo;flower.jpg&rsquo;);
const reader = response.body.getReader();</p>
<p>while(true) {
const {done, value} = await reader.read();</p>
<p>if (done) {
break;
}</p>
<p>console.log(<code>Received ${value.length} bytes</code>)
}</p>
<p>上面示例中，response.body.getReader()方法返回一个遍历器。这个遍历器的read()方法每次返回一个对象，表示本次读取的内容块。
这个对象的done属性是一个布尔值，用来判断有没有读完；value属性是一个 arrayBuffer 数组，表示内容块的内容，而value.length属性是当前块的大小。
三、fetch()的第二个参数：定制 HTTP 请求
fetch()的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求。</p>
<p>fetch(url, optionObj)</p>
<p>上面命令的optionObj就是第二个参数。
HTTP 请求的方法、标头、数据体都在这个对象里面设置。下面是一些示例。
（1）POST 请求</p>
<p>const response = await fetch(url, {
method: &lsquo;POST&rsquo;,
headers: {
&ldquo;Content-type&rdquo;: &ldquo;application/x-www-form-urlencoded; charset=UTF-8&rdquo;,
},
body: &lsquo;foo=bar&amp;lorem=ipsum&rsquo;,
});</p>
<p>const json = await response.json();</p>
<p>上面示例中，配置对象用到了三个属性。
method：HTTP 请求的方法，POST、DELETE、PUT都在这个属性设置。headers：一个对象，用来定制 HTTP 请求的标头。body：POST 请求的数据体。
注意，有些标头不能通过headers属性设置，比如Content-Length、Cookie、Host等等。它们是由浏览器自动生成，无法修改。
（2）提交 JSON 数据</p>
<p>const user =  { name:  &lsquo;John&rsquo;, surname:  &lsquo;Smith&rsquo;  };
const response = await fetch('/article/fetch/post/user', {
method: &lsquo;POST&rsquo;,
headers: {
&lsquo;Content-Type&rsquo;: &lsquo;application/json;charset=utf-8&rsquo;
}, 
body: JSON.stringify(user) 
});</p>
<p>上面示例中，标头Content-Type要设成&rsquo;application/json;charset=utf-8'。因为默认发送的是纯文本，Content-Type的默认值是&rsquo;text/plain;charset=UTF-8'。
（3）提交表单</p>
<p>const form = document.querySelector(&lsquo;form&rsquo;);</p>
<p>const response = await fetch('/users', {
method: &lsquo;POST&rsquo;,
body: new FormData(form)
})</p>
<p>（4）文件上传
如果表单里面有文件选择器，可以用前一个例子的写法，上传的文件包含在整个表单里面，一起提交。
另一种方法是用脚本添加文件，构造出一个表单，进行上传，请看下面的例子。</p>
<p>const input = document.querySelector(&lsquo;input[type=&ldquo;file&rdquo;]');</p>
<p>const data = new FormData();
data.append(&lsquo;file&rsquo;, input.files[0]);
data.append(&lsquo;user&rsquo;, &lsquo;foo&rsquo;);</p>
<p>fetch('/avatars&rsquo;, {
method: &lsquo;POST&rsquo;,
body: data
});</p>
<p>上传二进制文件时，不用修改标头的Content-Type，浏览器会自动设置。
（5）直接上传二进制数据
fetch()也可以直接上传二进制数据，将 Blob 或 arrayBuffer 数据放在body属性里面。</p>
<p>let blob = await new Promise(resolve =&gt;<br>
canvasElem.toBlob(resolve,  &lsquo;image/png&rsquo;)
);</p>
<p>let response = await fetch('/article/fetch/post/image', {
method:  &lsquo;POST&rsquo;,
body: blob
});</p>
</div></div></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.92.1">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">lyj</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
