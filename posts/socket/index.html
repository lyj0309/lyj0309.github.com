<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Socket - FAKEV</title><meta name=Description content="技术博客分享站"><meta property="og:title" content="Socket"><meta property="og:description" content="１、什么是Socket 在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算"><meta property="og:type" content="article"><meta property="og:url" content="https://fakev.cn/posts/socket/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-05T21:34:36+08:00"><meta property="article:modified_time" content="2022-04-05T21:34:36+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Socket"><meta name=twitter:description content="１、什么是Socket 在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算"><meta name=application-name content="FAKEV"><meta name=apple-mobile-web-app-title content="FAKEV"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://fakev.cn/posts/socket/><link rel=prev href=https://fakev.cn/posts/middleware/mysql/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Socket","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/fakev.cn\/posts\/socket\/"},"genre":"posts","keywords":"计网","wordcount":7556,"url":"https:\/\/fakev.cn\/posts\/socket\/","datePublished":"2022-04-05T21:34:36+08:00","dateModified":"2022-04-05T21:34:36+08:00","publisher":{"@type":"Organization","name":"lyj"},"author":{"@type":"Person","name":"lyj"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=FAKEV>FAKEV</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5481706144401224" crossorigin=anonymous></script></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=FAKEV>FAKEV</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Socket</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/lyj0309 title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>lyj</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-04-05>2022-04-05</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7556 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 16 分钟&nbsp;<span id=/posts/socket/ class=leancloud_visitors data-flag-title=Socket>
<i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#１什么是socket><strong>１、什么是Socket</strong></a></li><li><a href=#２网络中进程如何通信><strong>２、网络中进程如何通信</strong></a><ul><li></li></ul></li><li><a href=#３socket怎么通信><strong>３、Socket怎么通信</strong></a></li><li><a href=#４tcpip协议><strong>４、TCP/IP协议</strong></a><ul><li></li></ul></li><li><a href=#５osi模型><strong>５、OSI模型</strong></a></li><li><a href=#６socket常用函数接口及其原理><strong>６、Socket常用函数接口及其原理</strong></a><ul><li></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=１什么是socket><strong>１、什么是Socket</strong></h2><p>在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行<strong>通信</strong>的<strong>一种约定</strong>或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据<br>　　socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –> 读写write/read –> 关闭close”模式来操作。<br>　　我的理解就是Socket就是该模式的一个实现：即socket是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。<br>　　Socket()函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。</p><h2 id=２网络中进程如何通信><strong>２、网络中进程如何通信</strong></h2><p>既然Socket主要是用来解决网络通信的，那么我们就来理解网络中进程是如何通信的。</p><h4 id=21本地进程间通信>2.1、本地进程间通信</h4><p>a、消息传递（管道、消息队列、FIFO）<br>　　b、同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）<br>　　c、共享内存（匿名的和具名的，eg:channel）<br>　　d、远程过程调用(RPC)</p><h4 id=22网络中进程如何通信>2.2、网络中进程如何通信</h4><p>我们要理解网络中进程如何通信，得解决两个问题：<br>　　ａ、我们要如何标识一台主机，即怎样确定我们将要通信的进程是在那一台主机上运行。<br>　　ｂ、我们要如何标识唯一进程，本地通过pid标识，网络中应该怎样标识？<br>解决办法：<br>　　ａ、TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机<br>　　ｂ、传输层的“协议+端口”可以唯一标识主机中的应用程序（进程），因此，我们利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互</p><h2 id=３socket怎么通信><strong>３、Socket怎么通信</strong></h2><p>现在，我们知道了网络中进程间如何通信，即利用三元组【ip地址，协议，端口】可以进行网络间通信了，那我们应该怎么实现了，因此，我们socket应运而生，它就是利用三元组解决网络通信的一个中间件工具，就目前而言，几乎所有的应用程序都是采用socket，如UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰）。<br>Socket通信的数据传输方式，常用的有两种：<br>　　ａ、SOCK_STREAM：表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常见的 http 协议就使用 SOCK_STREAM 传输数据，因为要确保数据的正确性，否则网页不能正常解析。<br>　　ｂ、SOCK_DGRAM：表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为 SOCK_DGRAM 所做的校验工作少，所以效率比 SOCK_STREAM 高。<br>　　例如：QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响</p><h2 id=４tcpip协议><strong>４、TCP/IP协议</strong></h2><h4 id=41概念>4.1、概念</h4><p>TCP/IP【TCP（传输控制协议）和IP（网际协议）】提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。</p><p>它们之间好比送信的线路和驿站的作用，比如要建议送信驿站，必须得了解送信的各个细节。</p><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接，客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。<br>TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：</p><pre><code>[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”
[Shake 2] 套接字B：“好的，我这边已准备就绪。”
[Shake 3] 套接字A：“谢谢你受理我的请求。
</code></pre><h4 id=42tcp的粘包问题以及数据的无边界性httpsblogcsdnnetm0_37947204articledetails80490512httpslinksjianshucomgotohttps3a2f2fblogcsdnnet2fm0_379472042farticle2fdetails2f80490512>4.2、TCP的粘包问题以及数据的无边界性：　<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fm0_37947204%2Farticle%2Fdetails%2F80490512" target=_blank rel="noopener noreffer">https://blog.csdn.net/m0_37947204/article/details/80490512</a></h4><h4 id=44tcp数据报结构>4.4、TCP数据报结构：</h4><p><img class=lazyload src=/svg/loading.min.svg data-src=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6adt7r6j30a908cmxq.jpg data-srcset="https://wx1.sinaimg.cn/large/0077qBLuly1h0z6adt7r6j30a908cmxq.jpg, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6adt7r6j30a908cmxq.jpg 1.5x, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6adt7r6j30a908cmxq.jpg 2x" data-sizes=auto alt=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6adt7r6j30a908cmxq.jpg title=11362584-bf1bffccd9cceaff.webp></p><p>带阴影的几个字段需要重点说明一下：<br>　　(1) 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。<br>　　(2) 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。<br>　　(3) 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：</p><pre><code>（1）URG：紧急指针（urgent pointer）有效。
（2）ACK：确认序号有效。
（3）PSH：接收方应该尽快将这个报文交给应用层。
（4）RST：重置连接。
（5）SYN：建立一个新连接。
（6）FIN：断开一个连接。
</code></pre><h4 id=45连接的建立三次握手>4.5、连接的建立（三次握手）：</h4><p>使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图：</p><p>　　</p><p>20180529001324885.jpeg</p><p>客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求<br>这时客户端发起请求：<br>　　1) 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。<br>　　2) 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包<br>　　服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。<br>　　服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。<br>　　服务器将数据包发出，进入SYN-RECV状态<br>　　3) 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。<br>　　接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。<br>　　客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。<br>　　4) 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。<br>　　至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了。</p><h4 id=46tcp四次握手断开连接>4.6、TCP四次握手断开连接</h4><p>建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。<br>断开连接需要四次握手，可以形象的比喻为下面的对话：</p><pre><code>[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”
[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”
等待片刻后……
[Shake 3] 套接字B：“我准备好了，可以断开连接了。”
[Shake 4] 套接字A：“好的，谢谢合作。”
</code></pre><p>下图演示了客户端主动断开连接的场景：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6av92r0j30c60cvt9x.jpg data-srcset="https://wx1.sinaimg.cn/large/0077qBLuly1h0z6av92r0j30c60cvt9x.jpg, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6av92r0j30c60cvt9x.jpg 1.5x, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6av92r0j30c60cvt9x.jpg 2x" data-sizes=auto alt=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6av92r0j30c60cvt9x.jpg title=11362584-75c208edcfb986fc.webp>
建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求：</p><ol><li>客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。</li><li>服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。<br>注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。</li><li>客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。</li><li>等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。</li><li>客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。</li><li>服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。</li></ol><h4 id=47关于-time_wait-状态的说明>4.7、关于 TIME_WAIT 状态的说明</h4><p>客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，这是为什么呢？</p><p>TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，不能丢失或出错，而网络是不稳定的，随时可能会毁坏数据，所以机器A每次向机器B发送数据包后，都要求机器B”确认“，回传ACK包，告诉机器A我收到了，这样机器A才能知道数据传送成功了。如果机器B没有回传ACK包，机器A会重新发送，直到机器B回传ACK包。</p><p>客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。那么，要等待多久呢？</p><p>数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为报文最大生存时间（MSL，Maximum Segment Lifetime）。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包</p><h4 id=4８优雅的断开连接shutdown>4.８.优雅的断开连接–shutdown()</h4><p>close()/closesocket()和shutdown()的区别<br>确切地说，close() / closesocket() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，之后再也不能使用该套接字，与C语言中的 fclose() 类似。应用程序关闭套接字后，与该套接字相关的连接和缓存也失去了意义，TCP协议会自动触发关闭连接的操作。</p><p>shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() / closesocket() 将套接字从内存清除。<br>调用 close()/closesocket() 关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来了。</p><p>默认情况下，close()/closesocket() 会立即向网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。也就意味着，调用 close()/closesocket() 将丢失输出缓冲区中的数据，而调用 shutdown() 不会</p><h2 id=５osi模型><strong>５、OSI模型</strong></h2><p>TCP/IP对OSI的网络模型层进行了划分如下：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6b5rytuj30az08m0v0.jpg data-srcset="https://wx1.sinaimg.cn/large/0077qBLuly1h0z6b5rytuj30az08m0v0.jpg, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6b5rytuj30az08m0v0.jpg 1.5x, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6b5rytuj30az08m0v0.jpg 2x" data-sizes=auto alt=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6b5rytuj30az08m0v0.jpg title=11362584-d6275ac25abac5cc.webp></p><p>TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中<br>　　应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等<br>　　传输层：TCP，UDP<br>　　网络层：IP，ICMP，OSPF，EIGRP，IGMP<br>　　数据链路层：SLIP，CSLIP，PPP，MTU<br>　　每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的</p><p>　　
<img class=lazyload src=/svg/loading.min.svg data-src=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6baokdgj30f0094js6.jpg data-srcset="https://wx1.sinaimg.cn/large/0077qBLuly1h0z6baokdgj30f0094js6.jpg, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6baokdgj30f0094js6.jpg 1.5x, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6baokdgj30f0094js6.jpg 2x" data-sizes=auto alt=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6baokdgj30f0094js6.jpg title=11362584-2d26013c75ee45e1.webp>
<img class=lazyload src=/svg/loading.min.svg data-src=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bhcenhj30h00dr40p.jpg data-srcset="https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bhcenhj30h00dr40p.jpg, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bhcenhj30h00dr40p.jpg 1.5x, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bhcenhj30h00dr40p.jpg 2x" data-sizes=auto alt=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bhcenhj30h00dr40p.jpg title=11362584-157a39882f263361.webp></p><h2 id=６socket常用函数接口及其原理><strong>６、Socket常用函数接口及其原理</strong></h2><p>图解socket函数：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6blvucaj30fe09340o.jpg data-srcset="https://wx1.sinaimg.cn/large/0077qBLuly1h0z6blvucaj30fe09340o.jpg, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6blvucaj30fe09340o.jpg 1.5x, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6blvucaj30fe09340o.jpg 2x" data-sizes=auto alt=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6blvucaj30fe09340o.jpg title=11362584-31d594363f8cafa0.webp></p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bp6a0bj30da0dn0ty.jpg data-srcset="https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bp6a0bj30da0dn0ty.jpg, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bp6a0bj30da0dn0ty.jpg 1.5x, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bp6a0bj30da0dn0ty.jpg 2x" data-sizes=auto alt=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bp6a0bj30da0dn0ty.jpg title=11362584-ec76f69e2ea76d41.webp></p><h4 id=61使用socket函数创建套接字>6.1、使用socket()函数创建套接字</h4><pre><code>int socket(int af, int type, int protocol);
</code></pre><ol><li>af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。<br>大家需要记住127.0.0.1，它是一个特殊IP地址，表示本机地址，后面的教程会经常用到。</li><li>type 为数据传输方式，常用的有 SOCK_STREAM 和 SOCK_DGRAM</li><li>protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议</li></ol><h4 id=62使用bind和connect函数>6.2、使用bind()和connect()函数</h4><p>socket() 函数用来创建套接字，确定套接字的各种属性，然后服务器端要用 <strong>bind() 函数</strong>将套接字与特定的IP地址和端口绑定起来，只有这样，流经该IP地址和端口的数据才能交给套接字处理；而客户端要用 connect() 函数建立连接</p><pre><code>int bind(int sock, struct sockaddr *addr, socklen_t addrlen);  
</code></pre><p>sock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出<br>下面的代码，将创建的套接字与IP地址 127.0.0.1、端口 1234 绑定：</p><pre><code>//创建套接字
int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
//创建sockaddr_in结构体变量
struct sockaddr_in serv_addr;
memset(&amp;serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充
serv_addr.sin_family = AF_INET;  //使用IPv4地址
serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具体的IP地址
serv_addr.sin_port = htons(1234);  //端口
//将套接字和IP、端口绑定
bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));
</code></pre><p>connect() 函数用来建立连接，它的原型为：</p><pre><code>int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen); 
</code></pre><h4 id=63使用listen和accept函数>6.3、使用listen()和accept()函数</h4><p>于服务器端程序，使用 bind() 绑定套接字后，还需要使用 listen() 函数让套接字进入被动监听状态，再调用 accept() 函数，就可以随时响应客户端的请求了。<br>通过** listen() 函数**可以让套接字进入被动监听状态，它的原型为：</p><pre><code>int listen(int sock, int backlog); 
</code></pre><p>sock 为需要进入监听状态的套接字，backlog 为请求队列的最大长度。<br>所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。</p><p>请求队列<br>当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。</p><p>缓冲区的长度（能存放多少个客户端请求）可以通过 listen() 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是10或者20。</p><p>如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。</p><p>当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误</p><p>注意：listen() 只是让套接字处于监听状态，并没有接收请求。接收请求需要使用 accept() 函数。</p><p>当套接字处于监听状态时，可以通过 <strong>accept() 函数</strong>来接收客户端请求。它的原型为：</p><pre><code>int accept(int sock, struct sockaddr *addr, socklen_t *addrlen); 
</code></pre><p>它的参数与 listen() 和 connect() 是相同的：sock 为服务器端套接字，addr 为 sockaddr_in 结构体变量，addrlen 为参数 addr 的长度，可由 sizeof() 求得。</p><p>accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，大家注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。</p><p>最后需要说明的是：listen() 只是让套接字进入监听状态，并没有真正接收客户端请求，listen() 后面的代码会继续执行，直到遇到 accept()。accept() 会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。</p><h4 id=64socket数据的接收和发送>6.4、socket数据的接收和发送</h4><p>Linux下数据的接收和发送<br>Linux 不区分套接字文件和普通文件，使用 write() 可以向套接字中写入数据，使用 read() 可以从套接字中读取数据。</p><p>前面我们说过，两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 write() 向套接字写入数据，客户端就能收到，然后再使用 read() 从套接字中读取出来，就完成了一次通信。<br>write() 的原型为：</p><pre><code>ssize_t write(int fd, const void *buf, size_t nbytes);
</code></pre><p>fd 为要写入的文件的描述符，buf 为要写入的数据的缓冲区地址，nbytes 为要写入的数据的字节数。<br>write() 函数会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 -1。<br>read() 的原型为：</p><pre><code>ssize_t read(int fd, void *buf, size_t nbytes);
</code></pre><p>fd 为要读取的文件的描述符，buf 为要接收数据的缓冲区地址，nbytes 为要读取的数据的字节数。</p><p>read() 函数会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。</p><h4 id=65socket缓冲区以及阻塞模式>6.5、socket缓冲区以及阻塞模式</h4><p>socket缓冲区<br>每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。</p><p>write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。</p><p>TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。</p><p>read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bxeh6yj30jd05uq3w.jpg data-srcset="https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bxeh6yj30jd05uq3w.jpg, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bxeh6yj30jd05uq3w.jpg 1.5x, https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bxeh6yj30jd05uq3w.jpg 2x" data-sizes=auto alt=https://wx1.sinaimg.cn/large/0077qBLuly1h0z6bxeh6yj30jd05uq3w.jpg title=11362584-d4be2dd4bb3a26b8.webp></p><p>这些I/O缓冲区特性可整理如下：</p><pre><code>（1）I/O缓冲区在每个TCP套接字中单独存在；
（2）I/O缓冲区在创建套接字时自动生成；
（3）即使关闭套接字也会继续传送输出缓冲区中遗留的数据；
（4）关闭套接字将丢失输入缓冲区中的数据。
</code></pre><p>输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取：</p><pre><code>unsigned optVal;
int optLen = sizeof(int);
getsockopt(servSock, SOL_SOCKET, SO_SNDBUF, (char*)&amp;optVal, &amp;optLen);
printf(&quot;Buffer length: %d\n&quot;, optVal);
</code></pre><p>阻塞模式<br>对于TCP套接字（默认情况下），当使用 write()/send() 发送数据时：</p><pre><code>1) 首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()/send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()/send() 函数继续写入数据。
2) 如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()/send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()/send() 才会被唤醒。
3) 如果要写入的数据大于缓冲区的最大长度，那么将分批写入。
4) 直到所有数据被写入缓冲区 write()/send() 才能返回。
</code></pre><p>当使用 read()/recv() 读取数据时：</p><pre><code>1) 首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。
2) 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()/recv() 函数再次读取。
3) 直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。
这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。
</code></pre><p>TCP套接字默认情况下是阻塞模式</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-04-05</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/posts/socket/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E8%AE%A1%E7%BD%91/>计网</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/middleware/mysql/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/ class=prev rel=prev title=存储过程><i class="fas fa-angle-left fa-fw"></i>存储过程</a></div></div><div id=comments><div id=valine class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://valine.js.org/>Valine</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.85.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2020 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/lyj0309 target=_blank>lyj</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a class=theme-link href=https://beian.miit.gov.cn>桂ICP备20003848号</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/valine/valine.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/lib/valine/Valine.min.js></script><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{valine:{appId:"xp0QpOaiSAHWtssGMmuQsDK2-gzGzoHsz",appKey:"0jJ0r2V5ATEHonjSfXoY4Swn",avatar:"mp",el:"#valine",emojiCDN:"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/",emojiMaps:{100:"1f4af.png",alien:"1f47d.png",anger:"1f4a2.png",angry:"1f620.png",anguished:"1f627.png",astonished:"1f632.png",black_heart:"1f5a4.png",blue_heart:"1f499.png",blush:"1f60a.png",bomb:"1f4a3.png",boom:"1f4a5.png",broken_heart:"1f494.png",brown_heart:"1f90e.png",clown_face:"1f921.png",cold_face:"1f976.png",cold_sweat:"1f630.png",confounded:"1f616.png",confused:"1f615.png",cry:"1f622.png",crying_cat_face:"1f63f.png",cupid:"1f498.png",dash:"1f4a8.png",disappointed:"1f61e.png",disappointed_relieved:"1f625.png",dizzy:"1f4ab.png",dizzy_face:"1f635.png",drooling_face:"1f924.png",exploding_head:"1f92f.png",expressionless:"1f611.png",face_vomiting:"1f92e.png",face_with_cowboy_hat:"1f920.png",face_with_hand_over_mouth:"1f92d.png",face_with_head_bandage:"1f915.png",face_with_monocle:"1f9d0.png",face_with_raised_eyebrow:"1f928.png",face_with_rolling_eyes:"1f644.png",face_with_symbols_on_mouth:"1f92c.png",face_with_thermometer:"1f912.png",fearful:"1f628.png",flushed:"1f633.png",frowning:"1f626.png",ghost:"1f47b.png",gift_heart:"1f49d.png",green_heart:"1f49a.png",grimacing:"1f62c.png",grin:"1f601.png",grinning:"1f600.png",hankey:"1f4a9.png",hear_no_evil:"1f649.png",heart:"2764-fe0f.png",heart_decoration:"1f49f.png",heart_eyes:"1f60d.png",heart_eyes_cat:"1f63b.png",heartbeat:"1f493.png",heartpulse:"1f497.png",heavy_heart_exclamation_mark_ornament:"2763-fe0f.png",hole:"1f573-fe0f.png",hot_face:"1f975.png",hugging_face:"1f917.png",hushed:"1f62f.png",imp:"1f47f.png",innocent:"1f607.png",japanese_goblin:"1f47a.png",japanese_ogre:"1f479.png",joy:"1f602.png",joy_cat:"1f639.png",kiss:"1f48b.png",kissing:"1f617.png",kissing_cat:"1f63d.png",kissing_closed_eyes:"1f61a.png",kissing_heart:"1f618.png",kissing_smiling_eyes:"1f619.png",laughing:"1f606.png",left_speech_bubble:"1f5e8-fe0f.png",love_letter:"1f48c.png",lying_face:"1f925.png",mask:"1f637.png",money_mouth_face:"1f911.png",nauseated_face:"1f922.png",nerd_face:"1f913.png",neutral_face:"1f610.png",no_mouth:"1f636.png",open_mouth:"1f62e.png",orange_heart:"1f9e1.png",partying_face:"1f973.png",pensive:"1f614.png",persevere:"1f623.png",pleading_face:"1f97a.png",pouting_cat:"1f63e.png",purple_heart:"1f49c.png",rage:"1f621.png",relaxed:"263a-fe0f.png",relieved:"1f60c.png",revolving_hearts:"1f49e.png",right_anger_bubble:"1f5ef-fe0f.png",robot_face:"1f916.png",rolling_on_the_floor_laughing:"1f923.png",scream:"1f631.png",scream_cat:"1f640.png",see_no_evil:"1f648.png",shushing_face:"1f92b.png",skull:"1f480.png",skull_and_crossbones:"2620-fe0f.png",sleeping:"1f634.png",sleepy:"1f62a.png",slightly_frowning_face:"1f641.png",slightly_smiling_face:"1f642.png",smile:"1f604.png",smile_cat:"1f638.png",smiley:"1f603.png",smiley_cat:"1f63a.png",smiling_face_with_3_hearts:"1f970.png",smiling_imp:"1f608.png",smirk:"1f60f.png",smirk_cat:"1f63c.png",sneezing_face:"1f927.png",sob:"1f62d.png",space_invader:"1f47e.png",sparkling_heart:"1f496.png",speak_no_evil:"1f64a.png",speech_balloon:"1f4ac.png","star-struck":"1f929.png",stuck_out_tongue:"1f61b.png",stuck_out_tongue_closed_eyes:"1f61d.png",stuck_out_tongue_winking_eye:"1f61c.png",sunglasses:"1f60e.png",sweat:"1f613.png",sweat_drops:"1f4a6.png",sweat_smile:"1f605.png",thinking_face:"1f914.png",thought_balloon:"1f4ad.png",tired_face:"1f62b.png",triumph:"1f624.png",two_hearts:"1f495.png",unamused:"1f612.png",upside_down_face:"1f643.png",weary:"1f629.png",white_frowning_face:"2639-fe0f.png",white_heart:"1f90d.png",wink:"1f609.png",woozy_face:"1f974.png",worried:"1f61f.png",yawning_face:"1f971.png",yellow_heart:"1f49b.png",yum:"1f60b.png",zany_face:"1f92a.png",zipper_mouth_face:"1f910.png",zzz:"1f4a4.png"},enableQQ:!1,highlight:!0,lang:"zh-cn",pageSize:10,placeholder:"说点什么吧...",recordIP:!0,visitor:!0}},cookieconsent:{content:{dismiss:"同意",endlevel:6,link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"2JCAO8XQY2",algoliaIndex:"blog",algoliaSearchKey:"fd39521e89aef7cc0d57626786cf0644",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>